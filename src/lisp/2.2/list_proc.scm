(display "list proc\n")

; 2.36
(define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs))
        )
    )
)
; some errors 
(define (count-leaves2 tree)
    (accumulate (lambda (x y) (+ 1 y))
                0
                ( map enumerate-one-node tree)
    )
)
(define (enumerate-one-node x)
    (cond ((null? x) '())
        ((not (pair? x)) (list x))
        (else (append (enumerate-one-node (car x)) (enumerate-one-node (cdr x)) ))
        )
)
; (define (map-tree tree)
    
; )

(define (count-leaves x)
  (cond ( (null? x) 0)
      ((not (pair? x)) 1)
      (else (+ (count-leaves (car x)) (count-leaves (cdr x))))
      )
)
;2.34
(define (horner-eval x co-seq)
    (accumulate (lambda (this-coeff high-terms) 
                (+ (* x high-terms)  this-coeff)
                )
              0
            co-seq 
    )
)
; 2.33
(define (length seq)
    (accumulate (lambda (x y) (+ 1 y) ) 0 seq)
)
(define (append2 seq1 seq2)
    (accumulate cons seq2 seq1)
)
(define (map-a p sequence)
    (accumulate (lambda (x y) ( cons (p x)  y ) ) '() sequence)
)

(define (product-of-square-of-odd-elements sequence)
    (accumulate * 1 (map square (filter odd? sequence)))
)
(define (enumerate-tree tree )
    (cond ((null? tree) tree)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))
    )
)
(define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low (enumerate-interval (+ 1 low) high))
    )
)
(define (accumulate op initial sequence)
    (if (null? sequence) initial
        (op (car sequence) (accumulate op initial (cdr sequence)))
    )
)
(define (filter predicate sequence)
    (cond ((null? sequence) '())
        (   (predicate (car sequence)) 
            (cons (car sequence) (filter predicate (cdr sequence)))
        )
        (else (filter predicate (cdr sequence)))
        )
)
(define (list-fib-square n)
    (accumulate cons '() 
                (map square (map fib (enumerate-interval 0 n)))
    )
)
(define (even-fibs2 n)
    (accumulate cons
                '()
                (filter even? 
                        (map fib (enumerate-interval 0 n))
                )
    )
)
(define (even-fibs n)
    (define (next k)
        (if (> k n)
            '()
            (
                let ((f (fib k)))
                (if (even? f) 
                    (cons  f (next (+ 1 k)))
                    (next (+ 1 k))
                )
            )
        )
    )
    (next 0)
)

(define (fib n)
    (define (fib-iter k a b)
        (
            if (> k n)
                b
                (fib-iter (+ 1 k) (+ a b) a)
        )
    )
    (fib-iter 0 0 1)
)
(define (sum-odd-square2 tree)
    (accumulate +
                0
                (map square 
                    (filter odd? (enumerate-tree tree))
                )
    )
)
(define (sum-odd-square x)
    (cond (
        (null? x) 0)
        ((not (pair? x)) 
            (if (odd? x) 
                (square x) 
                0
            )
        )
        (else (+ (sum-odd-square (car x)) (sum-odd-square (cdr x)) ))
    )
)

(define (square x)
    (* x x)
)
(define (displaynewline x)
    (display x)
    (newline)
)

(define x (list 1 (list 2 (list 3 5 6))))
(displaynewline (sum-odd-square x))
(displaynewline (sum-odd-square2 x))
(displaynewline x)
(displaynewline (even-fibs 30))
(displaynewline (even-fibs2 30))
(displaynewline (filter odd? (list 1 2 3 4 5 11)))
(displaynewline (accumulate + 0 (list 1 2 3 4 5)))
(displaynewline (accumulate * 1 (list 1 2 3 4 5)))
(displaynewline (accumulate cons '() (list 1 2 3 4 5)))
(displaynewline (enumerate-interval 3 10))
(displaynewline (enumerate-tree x))
(displaynewline (list-fib-square 10))
(displaynewline (product-of-square-of-odd-elements  (list 1 2 3 4 5)))
(displaynewline (map-a (lambda (x) (* 2 x)) (list 1 2 3 4 5)))
(displaynewline (append2  (list 1 2 3) (list 4 5)))
(displaynewline "legnth:")
(displaynewline (length  (list 1 2 3 4 5 6 7 8 9 10 ) ))

(displaynewline (horner-eval 2 (list 1 3 0 5 0 1)))
(define y (list 1 (list 2) 3 (list 4 5) ))

(display "count-leaves:")
(displaynewline (count-leaves (list 1 (list 2) 3 (list 4 5) )))
(display "count-leaves2:")
(displaynewline (count-leaves2 (list 1 (list 2) 3 (list 4 5) )))
(displaynewline (length (enumerate-tree x)))
(displaynewline (enumerate-tree x))
(displaynewline (count-leaves (enumerate-tree y)))

(define z (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(displaynewline (map car z))
(displaynewline (map cdr z))
(displaynewline (accumulate-n + 0 z))





